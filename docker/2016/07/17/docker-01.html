<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hello,every body!"><title>docker系列(一)docker基础命令与dockerfile文件创建镜像 | troyCoder</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">docker系列(一)docker基础命令与dockerfile文件创建镜像</h1><a id="logo" href="/.">troyCoder</a><p class="description">爱生活爱编程，分享学习工作中的知识和见解！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/history/"><i class="fa fa-history"> 历史</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">docker系列(一)docker基础命令与dockerfile文件创建镜像</h1><div class="post-meta">Jul 17, 2016<span> | </span><span class="category"><a href="/categories/docker/">docker</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="docker/2016/07/17/docker-01.html" href="/docker/2016/07/17/docker-01.html#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker基础命令和含义"><span class="toc-number">2.1.</span> <span class="toc-text">docker基础命令和含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-run命令的中的参数以及含义"><span class="toc-number">2.2.</span> <span class="toc-text">docker run命令的中的参数以及含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过Dockerfile构建镜像"><span class="toc-number">2.3.</span> <span class="toc-text">通过Dockerfile构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dockerfiles基础说明"><span class="toc-number">2.3.1.</span> <span class="toc-text">Dockerfiles基础说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dockerfile指令介绍："><span class="toc-number">2.3.2.</span> <span class="toc-text">Dockerfile指令介绍：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile案例"><span class="toc-number">2.4.</span> <span class="toc-text">dockerfile案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#示例一：创建一个MongoDB的镜像"><span class="toc-number">2.4.1.</span> <span class="toc-text">示例一：创建一个MongoDB的镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#示例二：创建一个JAVA-Tomcat的镜像"><span class="toc-number">2.4.2.</span> <span class="toc-text">示例二：创建一个JAVA Tomcat的镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考："><span class="toc-number">3.</span> <span class="toc-text">参考：</span></a></li></ol></div></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期烦心事太多，包括工作、生活上的。归根结底还是自己不够强大，对于博客还没有坚持一个星期两篇博文，那就先坚持一个星期一篇吧，从简单开始，从放下开始，尽量让自己每时每个，坚持一些向上的的东西。对于这篇文章，docker目前一直在用，所以总结了一些关于docker基础性的东西。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="docker基础命令和含义"><a href="#docker基础命令和含义" class="headerlink" title="docker基础命令和含义"></a>docker基础命令和含义</h4><ol>
<li>docker version<br>显示 Docker 版本信息。</li>
<li>docker info<br>显示 Docker 系统信息，包括镜像和容器数。</li>
<li>docker search<br>从 Docker Hub 中搜索符合条件的镜像。</li>
<li>docker pull<br>从 Docker Hub 中拉取或者更新指定镜像。</li>
<li>docker login<br>按步骤输入在 Docker Hub 注册的用户名、密码和邮箱即可完成登录。</li>
<li>docker logout<br>运行后从指定服务器登出，默认为官方服务器。</li>
<li>docker images<br>列出本地所有镜像。其中 [name] 对镜像名称进行关键词查询。</li>
<li>docker ps<br>列出所有运行中容器。</li>
<li>docker rmi<br>从本地移除一个或多个指定的镜像。</li>
<li>docker rm<br>移除一个或多个指定的容器</li>
<li>docker history<br>查看指定镜像的创建历史。</li>
<li>docker create|start|stop|restart|pause|unpause<br>创建、启动、停止、重启、暂停和恢复一个或多个指定容器。</li>
<li>docker kill<br>杀死一个或多个指定容器进程。</li>
<li>docker events<br>从服务器拉取个人动态，可选择时间区间。</li>
<li>docker save<br>docker save &gt; “debian.tar”<br>将指定镜像保存成 tar 归档文件， docker load 的逆操作。保存后再加载（saved-loaded）的镜像不会丢失提交历史和层，可以回滚。</li>
<li>docker load<br>docker load &lt; debian.tar<br>从 tar 镜像归档中载入镜像， docker save 的逆操作。保存后再加载（saved-loaded）的镜像不会丢失提交历史和层，可以回滚。</li>
<li>docker export<br>docker export <container><br>将指定的容器保存成 tar 归档文件， docker import 的逆操作。导出后导入（exported-imported)）的容器会丢失所有的提交历史，无法回滚。</container></li>
<li>docker import<br>docker import url|-  “o”&gt;[repository[:tag “o”&gt;]]<br>从归档文件（支持远程文件）创建一个镜像， export 的逆操作，可为导入镜像打上标签。导出后导入（exported-imported)）的容器会丢失所有的提交历史，无法回滚。</li>
<li>docker top<br>docker top <running_container>  “o”&gt;[ps options]<br>查看一个正在运行容器进程，支持 ps 命令参数。</running_container></li>
<li>docker inspect<br>docker instpect nginx:latest<br>检查镜像或者容器的参数，默认返回 JSON 格式。</li>
<li>docker pause<br>暂停某一容器的所有进程。</li>
<li>docker unpause<br>docker unpause <container><br>恢复某一容器的所有进程。</container></li>
<li>docker tag<br>docker tag [options “o”&gt;] <image>[:tag “o”&gt;] [repository/ “o”&gt;][username/]name “o”&gt;[:tag]<br>标记本地镜像，将其归入某一仓库。</image></li>
<li>docker push<br>docker push laozhu/nginx:latest<br>将镜像推送至远程仓库，默认为 Docker Hub 。</li>
<li>docker logs<br>docker logs [options “o”&gt;] <container><br>docker logs -f -t –tail= “s2”&gt;”10” insane_babbage<br>获取容器运行时的输出日志。</container></li>
<li>docker run<br>docker run [options “o”&gt;] <image> [ “nb”&gt;command]  “o”&gt;[arg…]<br>启动一个容器，在其中运行指定命令。见下面详细说明。</image></li>
</ol>
<h4 id="docker-run命令的中的参数以及含义"><a href="#docker-run命令的中的参数以及含义" class="headerlink" title="docker run命令的中的参数以及含义"></a>docker run命令的中的参数以及含义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [options <span class="string">"o"</span>&gt;] &lt;image&gt; [ <span class="string">"nb"</span>&gt;<span class="built_in">command</span>]  <span class="string">"o"</span>&gt;[arg...]</div></pre></td></tr></table></figure>
<p>启动一个容器，在其中运行指定命令。<br>-a stdin 指定标准输入输出内容类型，可选 STDIN/<br>STDOUT / STDERR 三项；<br>-d 后台运行容器，并返回容器ID；<br>-i 以交互模式运行容器，通常与 -t 同时使用；<br>-t 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–name=”nginx-lb” 为容器指定一个名称；<br>–dns 8.8.8.8 指定容器使用的DNS服务器，默认和宿主一致；<br>–dns-search example.com 指定容器DNS搜索域名，默认和宿主一致；<br>-h “mars” 指定容器的hostname；<br>-e username=”ritchie” 设置环境变量；<br>–env-file=[] 从指定文件读入环境变量；<br>–cpuset=”0-2” or –cpuset=”0,1,2”绑定容器到指定CPU运行；<br>-c 可以调整container的cpu优先级。默认情况下，所有的container享有相同的cpu优先级和cpu调度周期。但你可以通过Docker来通知内核给予某个或某几个container更多的cpu计算周期。<br>　　默认情况下，使用-c或者–cpu-shares 参数值为0，可以赋予当前活动container 1024个cpu共享周期。这个0值可以针对活动的container进行修改来调整不同的cpu循环周期。<br>　　比如，我们使用-c或者–cpu-shares =0启动了C0，C1，C2三个container，使用-c/–cpu-shares=512启动了C3.这时，C0，C1，C2可以100%的使用CPU资源(1024)，但C3只能使用50%的CPU资源(512)。如果这个host的OS是时序调度类型的，每个CPU时间片是100微秒，那么C0，C1，C2将完全使用掉这100微秒，而C3只能使用50微秒。<br>-m 可以很方便的调整container所使用的内存资源。如果host支持swap内存，那么使用-m可以设定比host物理内存还大的值。<br>–net=”bridge” 指定容器的网络连接类型，支持 bridge /host / none container:<name|id> 四种类型；<br>–expose=[] 可以让container接受外部传入的数据。container内监听的port不需要和外部host的port相同。比如说在container内部，一个HTTP服务监听在80端口，对应外部host的port就可能是49880.<br>　　操作人员可以使用–expose，让新的container访问到这个container。具体有三个方式：<br>　　1. 使用-p来启动container。<br>　　2. 使用-P来启动container。<br>　　3. 使用–link来启动container。<br>-p 如果使用-p或者-P，那么container会开发部分端口到host，只要对方可以连接到host，就可以连接到container内部。当使用-P时，docker会在host中随机从49153 和65535之间查找一个未被占用的端口绑定到container。你可以使用docker port来查找这个随机绑定端口。<br>–link=[] 当你使用–link方式时，作为客户端的container可以通过私有网络形式访问到这个container。同时Docker会在客户端的container中设定一些环境变量来记录绑定的IP和PORT。<br>-v=[]: docker可以支持把一个宿主机上的目录挂载到镜像里。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</div></pre></td></tr></table></figure></name|id></p>
<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。<br>现在镜像内就可以共享宿主机里的文件了。<br>默认挂载的路径权限为读写。如果指定为只读可以用：ro<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -v /home/dock/Downloads:/usr/Downloads:ro ubuntu64 /bin/bash</div></pre></td></tr></table></figure></p>
<p>docker还提供了一种高级的用法。叫数据卷。<br>数据卷：“其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的”。感觉像是由一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息。<br>看示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -v /home/dock/Downloads:/usr/Downloads  --name dataVol ubuntu64 /bin/bash</div></pre></td></tr></table></figure></p>
<p>创建一个普通的容器。用–name给他指定了一个名（不指定的话会生成一个随机的名子）。<br>再创建一个新的容器，来使用这个数据卷。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it --volumes-from dataVol ubuntu64 /bin/bash</div></pre></td></tr></table></figure></p>
<p>–volumes-from用来指定要从哪个数据卷来挂载数据。<br>-u: USERcontainer中默认的用户是root。但是开发人员创建新的用户之后，这些新用户也是可以使用的。开发人员可以通过Dockerfile的USER设定默认的用户，操作人员可以通过”-u”来覆盖这些参数。<br>-w: WORKDIR<br>container中默认的工作目录是根目录(/)。开发人员可以通过Dockerfile的WORKDIR来设定默认工作目录，操作人员可以通过”-w”来覆盖默认的工作目录。</p>
<h4 id="通过Dockerfile构建镜像"><a href="#通过Dockerfile构建镜像" class="headerlink" title="通过Dockerfile构建镜像"></a>通过Dockerfile构建镜像</h4><h5 id="Dockerfiles基础说明"><a href="#Dockerfiles基础说明" class="headerlink" title="Dockerfiles基础说明"></a>Dockerfiles基础说明</h5><p>Dockerfiles是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它们简化了从头到尾的流程并极大的简化了 部署工作。Dockerfile从FROM命令开始，紧接着跟随者各种方法，命令和参数。其产出为一个新的可以用于创建容器的镜像。</p>
<h5 id="Dockerfile指令介绍："><a href="#Dockerfile指令介绍：" class="headerlink" title="Dockerfile指令介绍："></a>Dockerfile指令介绍：</h5><p><strong>FROM</strong><br>  语法：FROM <image>[:<tag>]<br>  解释：设置要制作的镜像基于哪个镜像，FROM指令必须是整个Dockerfile的第一个指令，如果指定的镜像不存在默认会自动从Docker Hub上下载。<br><strong>MAINTAINER</strong><br>  语法：MAINTAINER <name><br>  解释：MAINTAINER指令允许你给将要制作的镜像设置作者信息<br><strong>RUN</strong><br>  语法：①RUN <command>        #将会调用/bin/sh -c <command><br>  RUN [“executable”, “param1”, “param2”]    #将会调用exec执行，以避免有些时候shell方式执行时的传递参数问题，而且有些基础镜像可能不包含/bin/sh<br>  解释：RUN指令会在一个新的容器中执行任何命令，然后把执行后的改变提交到当前镜像，提交后的镜像会被用于Dockerfile中定义的下一步操作，RUN中定义的命令会按顺序执行并提交，这正是Docker廉价的提交和可以基于镜像的任何一个历史点创建容器的好处，就像版本控制工具一样。<br><strong>CMD</strong><br>  语法：①CMD [“executable”, “param1”, “param2”]    #将会调用exec执行，首选方式<br>  CMD [“param1”, “param2”]        #当使用ENTRYPOINT指令时，为该指令传递默认参数<br>  CMD <command> [ <param1>|<param2> ]        #将会调用/bin/sh -c执行<br>  解释：CMD指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个CMD指令，则只有最后一个CMD指令有效。当出现ENTRYPOINT指令时，CMD中定义的内容会作为ENTRYPOINT指令的默认参数，也就是说可以使用CMD指令给ENTRYPOINT传递参数。<br>  注意：RUN和CMD都是执行命令，他们的差异在于RUN中定义的命令会在执行docker build命令创建镜像时执行，而CMD中定义的命令会在执行docker run命令运行镜像时执行，另外使用第一种语法也就是调用exec执行时，命令必须为绝对路径。<br><strong>EXPOSE</strong><br>  语法：EXPOSE <port> [ …]<br>  解释：EXPOSE指令用来告诉Docker这个容器在运行时会监听哪些端口，Docker在连接不同的容器(使用–link参数)时使用这些信息。<br><strong>ENV</strong><br>  语法：ENV <key> <value><br>  解释：ENV指令用于设置环境变量，在Dockerfile中这些设置的环境变量也会影响到RUN指令，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行docker run时添加–env <key>=<value>参数来修改。<br>  注意：最好不要定义那些可能和系统预定义的环境变量冲突的名字，否则可能会产生意想不到的结果。<br><strong>ADD</strong><br>  语法：ADD <src> <dest><br>  解释：ADD指令用于从指定路径拷贝一个文件或目录到容器的指定路径中，<src>是一个文件或目录的路径，也可以是一个url，路径是相对于该Dockerfile文件所在位置的相对路径，<dest>是目标容器的一个绝对路径，例如/home/yooke/Docker/Dockerfile这个文件中定义的，那么ADD /data.txt /db/指令将会尝试拷贝文件从/home/yooke/Docker/data.txt到将要生成的容器的/db/data.txt，且文件或目录的属组和属主分别为uid和gid为0的用户和组，如果是通过url方式获取的文件，则权限是600。<br>  注意：①如果执行docker build – &lt; somefile即通过标准输入来创建时，ADD指令只支持url方式，另外如果url需要认证，则可以通过RUN wget …或RUN curl …来完成，ADD指令不支持认证。<br>  <src>路径必须与Dockerfile在同级目录或子目录中，例如不能使用ADD ../somepath，因为在执行docker build时首先做的就是把Dockerfile所在目录包含子目录发送给docker的守护进程。<br>  如果<src>是一个url且<dest>不是以”/“结尾，则会下载文件并重命名为<dest>。<br>  如果<src>是一个url且<dest>以“/”结尾，则会下载文件到<dest>/<filename>，url必须是一个正常的路径形式，“<a href="http://example.com”像这样的url是不能正常工作的。" target="_blank" rel="external">http://example.com”像这样的url是不能正常工作的。</a><br>  如果<src>是一个本地的压缩包且<dest>是以“/”结尾的目录，则会调用“tar -x”命令解压缩，如果<dest>有同名文件则覆盖，但<src>是一个url时不会执行解压缩。<br><strong>COPY</strong><br>  语法：COPY <src> <dest><br>  解释：用法与ADD相同，不过<src>不支持使用url，所以在使用docker build – &lt; somefile时该指令不能使用。<br><strong>ENTRYPOINT</strong><br>  语法：ENTRYPOINT [“executable”, “param1”, “param2”]        #将会调用exec执行，首选方式<br>  ENTRYPOINT command param1 param2             #将会调用/bin/sh -c执行<br>  解释：ENTRYPOINT指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个ENTRYPOINT指令，则只有最后一个指令有效。ENTRYPOINT指令中指定的命令(exec执行的方式)可以通过docker run来传递参数，例如docker run <images> -l启动的容器将会把-l参数传递给ENTRYPOINT指令定义的命令并会覆盖CMD指令中定义的默认参数(如果有的话)，但不会覆盖该指令定义的参数，例如ENTRYPOINT [“ls”,”-a”]，CMD [“/etc”],当通过docker run <image>启动容器时该容器会运行ls -a /etc命令，当使用docker run <image> -l启动时该容器会运行ls -a -l命令，-l参数会覆盖CMD指令中定义的/etc参数。<br>  注意：<br>   ①当使用ENTRYPOINT指令时生成的镜像运行时只会执行该指令指定的命令。<br>   ②当出现ENTRYPOINT指令时CMD指令只可能(当ENTRYPOINT指令使用exec方式执行时)被当做ENTRYPOINT指令的参数使用，其他情况则会被忽略。<br><strong>VOLUME</strong><br>  语法：VOLUME [“samepath”]<br>  解释：VOLUME指令用来设置一个挂载点，可以用来让其他容器挂载以实现数据共享或对容器数据的备份、恢复或迁移，具体用法请参考其他文章。<br><strong>USER</strong><br>  语法：USER [username|uid]<br>  解释：USER指令用于设置用户或uid来运行生成的镜像和执行RUN指令。<br><strong>WORKDIR</strong><br>  语法：WORKDIR /path/to/workdir<br>  解释：WORKDIR指令用于设置Dockerfile中的RUN、CMD和ENTRYPOINT指令执行命令的工作目录(默认为/目录)，该指令在Dockerfile文件中可以出现多次，如果使用相对路径则为相对于WORKDIR上一次的值，例如WORKDIR /data，WORKDIR logs，RUN pwd最终输出的当前目录是/data/logs。<br><strong>ONBUILD</strong><br>  语法：ONBUILD [INSTRUCTION]<br>  解释：ONBUILD指令用来设置一些触发的指令，用于在当该镜像被作为基础镜像来创建其他镜像时(也就是Dockerfile中的FROM为当前镜像时)执行一些操作，ONBUILD中定义的指令会在用于生成其他镜像的Dockerfile文件的FROM指令之后被执行，上述介绍的任何一个指令都可以用于ONBUILD指令，可以用来执行一些因为环境而变化的操作，使镜像更加通用。<br>  注意：<br>   ①ONBUILD中定义的指令在当前镜像的build中不会被执行。<br>   ②可以通过查看docker inspeat <image>命令执行结果的OnBuild键来查看某个镜像ONBUILD指令定义的内容。<br>   ③ONBUILD中定义的指令会当做引用该镜像的Dockerfile文件的FROM指令的一部分来执行，执行顺序会按ONBUILD定义的先后顺序执行，如果ONBUILD中定义的任何一个指令运行失败，则会使FROM指令中断并导致整个build失败，当所有的ONBUILD中定义的指令成功完成后，会按正常顺序继续执行build。<br>   ④ONBUILD中定义的指令不会继承到当前引用的镜像中，也就是当引用ONBUILD的镜像创建完成后将会清除所有引用的ONBUILD指令。<br>   ⑤ONBUILD指令不允许嵌套，例如ONBUILD ONBUILD ADD . /data是不允许的。<br>   ⑥ONBUILD指令不会执行其定义的FROM或MAINTAINER指令。</image></image></image></images></src></dest></src></src></dest></dest></src></filename></dest></dest></src></dest></dest></src></src></dest></src></dest></src></value></key></value></key></port></param2></param1></name></tag></image></p>
<h4 id="dockerfile案例"><a href="#dockerfile案例" class="headerlink" title="dockerfile案例"></a>dockerfile案例</h4><h5 id="示例一：创建一个MongoDB的镜像"><a href="#示例一：创建一个MongoDB的镜像" class="headerlink" title="示例一：创建一个MongoDB的镜像"></a>示例一：创建一个MongoDB的镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">############################################################</span></div><div class="line"><span class="comment"># Dockerfile to build MongoDB container images</span></div><div class="line"><span class="comment"># Based on Ubuntu</span></div><div class="line"><span class="comment">############################################################</span></div><div class="line"><span class="comment"># Set the base image to Ubuntu</span></div><div class="line">FROM ubuntu</div><div class="line"><span class="comment"># File Author / Maintainer</span></div><div class="line">MAINTAINER Example McAuthor</div><div class="line"><span class="comment"># Update the repository sources list</span></div><div class="line">RUN apt-get update</div><div class="line"><span class="comment">################## BEGIN INSTALLATION ######################</span></div><div class="line"><span class="comment"># Install MongoDB Following the Instructions at MongoDB Docs</span></div><div class="line"><span class="comment"># Ref: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/</span></div><div class="line"><span class="comment"># Add the package verification key</span></div><div class="line">RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10</div><div class="line"><span class="comment"># Add MongoDB to the repository sources list</span></div><div class="line">RUN <span class="built_in">echo</span> <span class="string">'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen'</span> | tee /etc/apt/sources.list.d/mongodb.list</div><div class="line"><span class="comment"># Update the repository sources list once more</span></div><div class="line">RUN apt-get update</div><div class="line"><span class="comment"># Install MongoDB package (.deb)</span></div><div class="line">RUN apt-get install -y mongodb-10gen</div><div class="line"><span class="comment"># Create the default data directory</span></div><div class="line">RUN mkdir -p /data/db</div><div class="line"><span class="comment">##################### INSTALLATION END #####################</span></div><div class="line"><span class="comment"># Expose the default port</span></div><div class="line">EXPOSE 27017</div><div class="line"><span class="comment"># Default port to execute the entrypoint (MongoDB)</span></div><div class="line">CMD [<span class="string">"--port 27017"</span>]</div><div class="line"><span class="comment"># Set default container command</span></div><div class="line">ENTRYPOINT usr/bin/mongod</div></pre></td></tr></table></figure>
<p>使用上述的Dockerfile，我们已经可以开始构建MongoDB镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker build -t my_mongodb .</div></pre></td></tr></table></figure></p>
<h5 id="示例二：创建一个JAVA-Tomcat的镜像"><a href="#示例二：创建一个JAVA-Tomcat的镜像" class="headerlink" title="示例二：创建一个JAVA Tomcat的镜像"></a>示例二：创建一个JAVA Tomcat的镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># VERSION 0.0.1</span></div><div class="line"><span class="comment"># 默认ubuntu server长期支持版本，当前是12.04</span></div><div class="line">FROM ubuntu</div><div class="line"><span class="comment"># 签名啦</span></div><div class="line">MAINTAINER yongboy <span class="string">"yongboy@gmail.com"</span></div><div class="line"></div><div class="line"><span class="comment"># 更新源，安装ssh server</span></div><div class="line">RUN <span class="built_in">echo</span> <span class="string">"deb http://archive.ubuntu.com/ubuntu precise main universe"</span>&gt; /etc/apt/sources.list</div><div class="line">RUN apt-get update</div><div class="line"></div><div class="line">RUN apt-get install -y openssh-server</div><div class="line">RUN mkdir -p /var/run/sshd</div><div class="line"></div><div class="line"><span class="comment"># 设置root ssh远程登录密码为123456</span></div><div class="line">RUN <span class="built_in">echo</span> <span class="string">"root:123456"</span> | chpasswd </div><div class="line"></div><div class="line"><span class="comment"># install vim</span></div><div class="line">RUN apt-get -y remove vim-common</div><div class="line">RUN apt-get -y install vim</div><div class="line">  </div><div class="line"><span class="comment"># Install curl  </span></div><div class="line">RUN apt-get -y install curl</div><div class="line">RUN </div><div class="line">rm -rf /var/lib/apt/lists/*  </div><div class="line"><span class="comment"># Install JDK 7  </span></div><div class="line">RUN <span class="built_in">cd</span> /tmp &amp;&amp;  curl -L <span class="string">'http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz'</span> -H <span class="string">'Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile'</span> | tar -xz  </div><div class="line">RUN mkdir -p /usr/lib/jvm  </div><div class="line">RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </div><div class="line">  </div><div class="line"><span class="comment"># Set Oracle JDK 7 as default Java  </span></div><div class="line">RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300    </div><div class="line">RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300 </div><div class="line">  </div><div class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  </div><div class="line">  </div><div class="line"><span class="comment"># Install tomcat7  </span></div><div class="line">RUN <span class="built_in">cd</span> /tmp &amp;&amp; curl -L <span class="string">'http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz'</span> | tar -xz  </div><div class="line">RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </div><div class="line">  </div><div class="line">ENV CATALINA_HOME /opt/tomcat7  </div><div class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$CATALINA_HOME</span>/bin  </div><div class="line">  </div><div class="line">ADD tomcat7.sh /etc/init.d/tomcat7  </div><div class="line">RUN chmod 755 /etc/init.d/tomcat7  </div><div class="line"></div><div class="line"><span class="comment"># 容器需要开放SSH 22端口</span></div><div class="line">EXPOSE 22</div><div class="line"></div><div class="line"><span class="comment"># 容器需要开放Tomcat 8080端口</span></div><div class="line">EXPOSE 8080</div><div class="line"></div><div class="line"><span class="comment"># 设置Tomcat7初始化运行，SSH终端服务器作为后台运行</span></div><div class="line">ENTRYPOINT service tomcat7 start &amp;&amp; /usr/sbin/sshd -D &amp;&amp; tail <span class="_">-f</span> /opt/tomcat7/logs/catalina.out</div></pre></td></tr></table></figure>
<p><strong>需要注意：</strong><br>ENTRYPOINT，表示镜像在初始化时需要执行的命令，不可被重写覆盖，需谨记<br>CMD，表示镜像运行默认参数，可被重写覆盖<br>ENTRYPOINT/CMD都只能在文件中存在一次，并且最后一个生效 多个存在，只有最后一个生效，其它无效！<br>需要初始化运行多个命令，彼此之间可以使用 &amp;&amp; 隔开，但最后一个须要为无限运行的命令，需切记！<br>ENTRYPOINT/CMD，一般两者可以配合使用，比如：<br>ENTRYPOINT [“/usr/sbin/sshd”]<br>CMD [“-D”]<br>在Docker　daemon模式下，无论你是使用ENTRYPOINT，还是CMD，最后的命令，一定要是当前进程需要一直运行的，才能够防容器退出。<br>以下无效方式：<br> ENTRYPOINT service tomcat7 start #运行几秒钟之后，容器就会退出<br> CMD service tomcat7 start #运行几秒钟之后，容器就会退出<br>这样有效：<br>ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /var/lib/tomcat7/logs/catalina.out<br>或者<br>CMD service tomcat7 start &amp;&amp; tail -f /var/lib/tomcat7/logs/catalina.out<br>这样也有效：<br> ENTRYPOINT [“/usr/sbin/sshd”]<br> CMD [“-D”]<br>具体请参考官方文档：Dockerfiles for Images<br>构建镜像</p>
<p>脚本写好了，需要转换成镜像：<br>docker build -t yongboy/java7 .<br>-t： 为构建的镜像制定一个标签，便于记忆/索引等<br>. ： 指定Dockerfile文件在当前目录下<br>网速不太好，会等待很长时间。很多操作可能需要科学上网，逼得我只能一直挂着VPN，方能畅通无阻。<br>构建镜像完成之后，看看运行效果：<br>docker run -d -p 22 -p 8080:8080 yongboy/java7<br>在运行命令中，还得需要显式指定 -p 22 -p 8080:8080，否则在Docker 0.8.1版本中不会主动映射到宿主机上。据悉在Docker 0.4.8版本时，就不担心这个问题。 或者，您要有好的方式，不妨告知于我，谢谢。<br>在Dockerfile中，若没有使用ENTRYPOINT/CMD指令，若运行多个命令，可以这样做：<br>docker run -d -p 22 -p 8080 yongboy/java7 /bin/sh -c “service tomcat7 start &amp;&amp; /usr/sbin/sshd -D”<br>提交/保存镜像</p>
<p>创建好的镜像，可以保存到索引仓库中，便于下次使用（当然，我们直接共享Dockerfile，是最简单的事情，:)) ），但毕竟镜像可以做到开箱即用。<br><a href="https://index.docker.io/" target="_blank" rel="external">https://index.docker.io/</a> 注册一个账号，例如yongboy<br>构建镜像<br>docker build -t yongboy/java7 .<br>上面已经构建OK的话，可省略此步。<br>登陆<br>docker login<br>提交到Docker索引仓库<br>docker push yongboy/java7<br>现在可以起来喝杯热水，出去溜达会，也不一定能够上传完毕，那叫一个慢啊！<br>上传OK的话，可以得到类似地址：<a href="https://index.docker.io/u/yongboy/java7/" target="_blank" rel="external">https://index.docker.io/u/yongboy/java7/</a><br>如何使用镜像<br>docker pull yongboy/java7<br>剩下的步骤，就很简单了。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://wenku.baidu.com/link?url=wP5bW_rRwEDM71Uum8liLgL_aLTBV1JX2tjEijExkRqs-mvcSJdyhmtGoAhfU9v45LU0k0ltyzzCEk67KYxpatINlftgntGl5zRbdEgfJAO" title="命令" target="_blank" rel="external">docker命令语句</a><br><a href="http://my.oschina.net/2xixi/blog/516951" title="dockerfile详解" target="_blank" rel="external">dockerfile详解</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.troylc.cc/docker/2016/07/17/docker-01.html" data-id="cj059w6og001clsqyjd92zql3" class="article-share-link">分享到</a><div class="tags"><a href="/tags/linux/">linux</a><a href="/tags/docker/">docker</a></div><div class="post-nav"><a href="/linux/2016/07/23/linux-02.html" class="pre">linux系列(二)-linux相关系统进程查看及管理</a><a href="/linux/2016/07/10/linux-01.html" class="next">linux系列(一)-linux下的mysql定时备份-nfs异地存储</a></div><div data-thread-key="docker/2016/07/17/docker-01.html" data-title="docker系列(一)docker基础命令与dockerfile文件创建镜像" data-url="http://www.troylc.cc/docker/2016/07/17/docker-01.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="docker/2016/07/17/docker-01.html" data-title="docker系列(一)docker基础命令与dockerfile文件创建镜像" data-url="http://www.troylc.cc/docker/2016/07/17/docker-01.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker-compose/">docker-compose</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-cloud/">spring cloud</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/experience/">心得</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo优化/" style="font-size: 15px;">hexo优化</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/jenkins/" style="font-size: 15px;">jenkins</a> <a href="/tags/registry/" style="font-size: 15px;">registry</a> <a href="/tags/swarm/" style="font-size: 15px;">swarm</a> <a href="/tags/docker-compose/" style="font-size: 15px;">docker-compose</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/心得/" style="font-size: 15px;">心得</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/jacman/" style="font-size: 15px;">jacman</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring-boot</a> <a href="/tags/spring-cloud/" style="font-size: 15px;">spring cloud</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/04/24/spring-cloud-deploy.html">用docker构建与部署spring-cloud的微服务(七)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/04/16/spirng-cloud-config.html">SpringCloud构微服务之-配置中心(六)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/04/13/spirng-cloud-sidecar.html">SpringCloud构建异构平台的微服务之-sidecar(五)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/03/19/spirng-cloud-apigateway.html">SpringCloud和docker之微服务-apigateway(四)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/03/11/spirng-cloud-productservice.html">SpringCloud和docker之微服务-consumer(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/03/09/spirng-cloud-userservice.html">SpringCloud和docker之微服务-provider(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/spring-cloud/2017/03/01/spirng-cloud-eureka.html">SpringCloud和docker之微服务-eureka(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/docker-compose/2017/02/25/Docker08docker-compose01.html">docker-compose部署swarm服务(docker1.13.1)</a></li><li class="post-list-item"><a class="post-list-link" href="/docker/2017/02/19/Docker07docker-swarm02.html">docker1.12.3 docker-swarm集群服务部署与维护（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/java/2017/02/15/java01-thread-tools.html">java中并发工具包-同步器（一）</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.haomwei.com" title="屠夫9441的博客" target="_blank">屠夫9441的博客</a><ul></ul><a href="http://www.troylc.cc/" title="troylc博客" target="_blank">troylc博客</a></div><div class="widget"><div class="widget-title"><i class="fa fa-bar-chart"> 网站访问量</i></div><ul> </ul><a href="http://s05.flagcounter.com/more/IVe"><img src="http://s05.flagcounter.com/countxl/IVe/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/percent_0/" alt="" border="0" /></a></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 我的微博</i></div><ul> </ul><iframe width="100%" height="120 class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=199&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2705524937&verifier=0f81d6c8&dpc=1"></iframe></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">troyCoder.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'troylc'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b991924b21cd080f0a0e761ff1a69288";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>